# Tsukalos_M-Golang_for_profi-2020

## История GO
 
### Разработка

     Создателями Go являются профессиональные программисты Роберт Гризмер (Robert Griesemer), Кен Томсон (Ken Thomson) и Роб Пайк (Rob Pike)

### Преимущества Go
 - Код Go является переносимым, особенно между UNIX-машинами.
 -  Go поддерживает процедурное, параллельное и распределенное программирование.
 - Go поддерживает сборку мусора, поэтому вам не придется заниматься выделением и освобождением памяти.
 - У Go нет препроцессора; вместо этого выполняется высокоскоростная компиляция. Вследствие этого Go можно использовать как язык сценариев.
 - В стандартную библиотеку Go входит множество пакетов, которые упрощают жизнь разработчика. Функции, входящие в стандартную библиотеку Go, предварительно тестируются и отлаживаются людьми, разрабатывающими Go, а значит, в основном работают без ошибок.
 - По умолчанию в Go используется статическая компоновка - это значит, что создаваемые двоичные файлы легко переносятся на другие компьютеры с той же ОС. Как следствие, после успешной компиляции Go-программы и создания исполняемого файла не приходится беспокоиться о библиотеках, зависимостях и разных версиях этих библиотек.
### Недостатки GO
 -  у Go нет встроенной поддержки оъектно-ориентированного программирования. 

### Что такое препроцессор
 - Препроцессор — это текстовый процессор, управляющий текстом файла исходного кода в ходе первого этапа трансляции. Препроцессор не анализирует исходный текст, но разбивает его на маркеры для поиска вызовов макросов. Хотя компилятор обычно вызывает препроцессор при первом проходе, препроцессор можно также вызвать отдельно для обработки текста без его компиляции.
### Утилита godoc
позволяет просматривать документацию загруженных функций и пакетов Go без подключения к Интернету.
` go doc fmt.Printf`

## Go compiller
 - компиляция вызывается командой `gp build name.go`( статически скомпонован)
 - не имеет значения имя исходного файла с текстом программы, если именем пакета является main и в нем есть только одна функция main(). Дело в том, что именно с функции main() начинается выполнение программы.
## Выполнение Go-кода
 - ` go run aSourceFile.go`

## Два правила Go
   ### Правило пакетов Go: не нужен — не подключай
  - при компиляции программы с подключеной, но не используемой библиотекой будет получена ошибка.
  - Можно обойти, поставив _ перед импортом библиотеки `_"os"`
   ### Правильный вариант размещения фигурных скобок — всего один
  - ЭТО СИНТЕКСИЧЕСКАЯ ОШИБКА

## Как скачивать Go-пакеты 
    Имейте в виду, что недавно в Go появился новый функционал — модули,     которые все еще находятся в стадии разработки и поэтому могут внести     изменения в работу с внешним Go-кодом. Однако процедура загрузки     на компьютер отдельного Go-пакета останется прежней.    Вы узнаете намного больше о пакетах и модулях Go из главы 6.
 - чтобы скачать пакет необходимо выполнить.\
   `go get -v ithub.com/mactsouk/go/simpleGitHub `
 - Загруженные файлы вы найдете в следующем каталоге:\
`ls -l ~/go/src/github.com/mactsouk/go/simpleGitHub/`
 - команда go get также компилирует пакет.Соответствующие файлы размещаются здесь:\
`ls -l ~/go/pkg/darwin_amd64/github.com/ mactsouk/go/simpleGitHub.a`
## Вывод результатов
 - fmt.Println() 
 - fmt.Printf() - спецификатор формата (глаголы)  https://golang.org/pkg/fmt/.
 - fmt.Print()
###  семейство S-функций
Используются для построения строк по заданному формату
-  fmt.Sprintln()
-  fmt.Sprint()
-  fmt.Sprintf()
 ### семейство F-функций
Используются для записи в файлы с помощью io.Writer.
- fmt.Fprintln()
- fmt.Fprint()
- fmt.Fprintf().
 ### Использование стандартного потока вывода

```go
package main
import (
 "io"
 "os"
)
```
Вместо пакета fmt будет использоваться пакет io. Пакет os
применяется для чтения программой аргументов командной строки и для доступа 
к os.Stdout.
```go
func main() {
 myString := ""
 arguments := os.Args
 if len(arguments) == 1 {
 myString = "Please give me one argument!"
 } else {
 myString = arguments[1]
 }


 io.WriteString(os.Stdout, myString)
 io.WriteString(os.Stdout, "\n")
}
```
В данном случае функция io.WriteString() работает так же, как fmt.Print(), однако принимает только два параметра. Первый из них — это файл, в который будут записываться результаты, в данном случае os.Stdout, а второй — строковая 
переменная.
## Получение данных от пользователя
Способы: 
 -  прочитать аргументы командной строки программы
 -  предложить пользователю ввести данные
 -  прочитать внешние файлы.
### Что такое := и =
 -  := — сокращенный оператор присваивания.
   (Используется вместо объявления `var` с неявным типом)

     Ключевое слово `var` в Go-программах используется главным образом для объявления глобальных переменных, а также для объявления переменных без начального значения. Причина первого варианта заключается в том, что каждое утверждение, существующее вне кода функции, должно начинаться с ключевого слова, такого как `func` или `var`. Это означает, что сокращенный оператор присваивания нельзя использовать вне функции, потому что он там недоступен.
     
    Что произойдет, если мы ожидаем от функ-
    ции два значения или более и хотим использовать существующую переменную для 
    одного из них? Какой оператор применять: := или =? Ответ : оператор :=
### Чтение стандартного потока ввода
Обычно для ввода и вывода файлов используется пакет `bufio`, но в этой книге мы будем использовать в основном пакет `os`.

    Согласно официальному описанию пакета os в нем представлены функции, которые выполняют операции ОС. Сюда входят функции создания, удаления,     переименования файлов и каталогов, а также функции распознавания полномочий доступа UNIX и других характеристик файлов и каталогов.

```go
package main
import (
 "bufio"
 "fmt"
 "os"
)
func main(){
 var f *os.File
 f = os.Stdin
 defer f.Close()
 scanner := bufio.NewScanner(f)
 for scanner.Scan() {
 fmt.Println(">", scanner.Text())
 }
}

```
### Работа с аргументами командной строки


```go
package main
import (
 "fmt"
 "os"
 "strconv"
)

func main() {
 if len(os.Args) == 1 {
 fmt.Println("Please give one or more floats.")
 os.Exit(1)
 }
 arguments := os.Args
 min, _ := strconv.ParseFloat(arguments[1], 64)
 max, _ := strconv.ParseFloat(arguments[1], 64)

for i := 2; i < len(arguments); i++ {
 n, _ := strconv.ParseFloat(arguments[i], 64)
 
 if n < min {
 min = n
 }
 if n > max {
 max = n
 }
 }
 fmt.Println("Min:", min)
 fmt.Println("Max:", max)
}
```
   Здесь cla.go проверяет, есть ли у нас аргументы командной строки, контроли-
руя длину os.Args. Дело в том, что для работы программы необходим как минимум 
один аргумент командной строки. Обратите внимание, что os.Args — это срез Go, 
содержащий значения типа string. Первый элемент среза — это имя исполняемой 
программы.

cla.go игнорирует значение 
типа error, возвращаемое функцией strconv.ParseFloat()

Символ подчеркивания, который 
называют пустым идентификатором, является средством сброса значения в Go.
### Вывод ошибок
 метод передачи данных в стандартный поток ошибок
```go
package main
import (
 "io"
 "os"
)
func main() {
 myString := ""
 arguments := os.Args
 if len(arguments) == 1 {
 myString = "Please give me one argument!"
 } else {
 myString = arguments[1]
 }
До сих пор stdERR.go практически не отличается от stdOUT.go.
Вторая часть stdERR.go выглядит так:
 io.WriteString(os.Stdout, "This is Standard output\n")
 io.WriteString(os.Stderr, myString)
 io.WriteString(os.Stderr, "\n")
}
```
Выполнение stdERR.go даст следующий результат:
```bash
$ go run stdERR.go
This is Standard output
Please give me one argument!
```
При применении bash(1) можно перенаправить стандартный поток ошибок 
в файл:
```bash
$ go run stdERR.go 2>/tmp/stdError
This is Standard output
$ cat /tmp/stdError
Please give me one argument!
```
## Логирование

### Запись в журнальные файлы
   Пакет `log` позволяет отправлять журнальные сообщения в системную службу журналирования UNIX-машины, а Go-пакет `syslog`, который является частью пакета `log`, позволяет определить уровень журналирования и средство журналирования, которое будет использовать ваша Go-программа.
   Функции `log`:
   -  log.Printf()
   -  log.Print()
   -  log.Println()
   -  log.Fatalf()
   -  log.Fatalln()
   -  log.Panic()
   -  log.Panicln()
   -  log.Panicf()
   -  
### Уровни журналирования
    
   Уровень журналирования — это значение, которое определяет степень серьезности журнального сообщения. Существуют следующие уровни журналирования (в порядке возрастания серьезности): **debug, info, notice, warning, err, crit, alert** и **emerg**.
### Средства журналирования
   Средство журналирования подобно категории, используемой при регистрации информации. Средство журналирования принимает значения **auth, authpriv, cron, daemon, kern, lpr, mail, mark, news, syslog, user, UUCP, local0, local1, local2, local3, local4, local5, local6** или **local7** и определяется в файле */etc/syslog.conf*, */etc/rsyslog.conf*
### Серверы журналирования
     syslogd(8) и rsyslogd(8)
### Пример Go-программы, которая записывает информацию в журнальные файлы

```go
package main
import (
 "fmt"
 "log"
 "log/syslog"
 "os"
 "path/filepath"
)

func main() {
 programName := filepath.Base(os.Args[0])
 sysLog, err := syslog.New(syslog.LOG_INFO|syslog.LOG_LOCAL7, programName)

 if err != nil {
    log.Fatal(err)
 } else {
    log.SetOutput(sysLog)
 }
 log.Println("LOG_INFO + LOG_LOCAL7: Logging in Go!")


 sysLog, err = syslog.New(syslog.LOG_MAIL, "Some program!")
 if err != nil {
    log.Fatal(err)
 } else {
    log.SetOutput(sysLog)
 }
 log.Println("LOG_MAIL: Logging in Go!")
 fmt.Println("Will you see this?")
}
```
    Первым параметром функции syslog.New() является приоритет, который представляет собой соединение средства журналирования и уровня журналирования. Так, приоритет LOG_NOTICE | LOG_MAIL, который выбран в качестве примера, будет отправлять сообщения уровня журналирования NOTICE в средство журналирования MAIL.


    В результате этот код устанавливает такой режим журналирования по умолчанию: средство журналирования local7 и уровень журналирования info. Второй параметр функции syslog.New() — это имя процесса, который будет отображаться в журналах в качестве отправителя сообщения. Вообще, рекомендуется использо-
    вать настоящее имя исполняемого файла, чтобы впоследствии можно было легко найти нужную информацию в файлах журналов.

    log.SetOutput() задает приемник вывода для записи в журнал по умолчанию, — в данном случае это созданный нами ранее регистратор журнала (sysLog). Затем можно использовать функцию log.Println() для отправки информации на сервер журнала.
### Функция log.Fatal()
   Используется тогда, когда происходит что-то действительно очень плохое и вы просто хотите поскорее выйти из программы, предварительно отправив сообщение о сложной ситуации.

   При использовании log.Fatal() Go-программа завершается в том месте, где была вызвана функция log.Fatal()
### Функция log.Panic()
    log.Panic() —разновидности функций журналирования

    Таким образом, log.Panic() выводит дополнительную низкоуровневую информацию, которая, по идее, должна помочь разрешить сложную ситуацию, возникшую в Go-коде.
### Запись в специальный журнальный файл
  Назовем нашу Go-утилиту customLog.go и будем записывать данные в журнальный файл /tmp/mGo.log.

  ```go
 package main
import (
 "fmt"
 "log"
 "os"
)
var LOGFILE = "/tmp/mGo.log"
//Путь к журнальному файлу в customLog.go задан жестко как значение глобальной переменной с именем LOGFILE.
  
  func main() {
    // создаем новый журнальный файл, используя функцию os.OpenFile(), правами доступа к UNIX-файлам (0644)
    f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Println(err)
        return
 }
 defer f.Close()

 iLog := log.New(f, "customLogLineNumber ", log.LstdFlags)
 iLog.SetFlags(log.LstdFlags)
 iLog.Println("Hello there!")
 iLog.Println("Another log entry!")
}

  
  ```

   SetFlags позволяет устанавливать выходные флаги (варианты) для текущего средства журналирования.
### Вывод номеров строк в записях журнала
Запишем номер строки, которая сделала запись в лог 
```go

package main
import ( "fmt" "log" "os" )
var LOGFILE = "/tmp/mGo.log"
func main() {
 f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
 if err != nil {
    fmt.Println(err)
    return
 }
 defer f.Close()

 iLog := log.New(f, "customLogLineNumber ", log.LstdFlags)
 iLog.SetFlags(log.LstdFlags | log.Lshortfile)
 iLog.Println("Hello there!")
 iLog.Println("Another log entry!")
}
```
Всю магию выполняет оператор `iLog.SetFlags(log.LstdFlags | log.Lshortfile),` 
который, кроме `log.LstdFlags`, также активизирует флаг log.Lshortfile. Послед-
ний добавляет в строку записи журнала полное имя файла, а также номер строки 
Go-оператора, который создал эту запись.

## Обработка ошибок в Go
 **тип данных для ошибок — error**

    Ошибки в Go не похожи на исключения или ошибки в других языках программирования; это обычные объекты Go, которые возвращаются из функций или методов, подобно любым другим значениям.

### Создание ошибки
```go

package main
import (
    "errors"
    "fmt"
)

func returnError(a, b int) error {
    if a == b {
        err := errors.New("Error in returnError() function!")
        return err
    } else {
        return nil
    }
}

func main() {
    err := returnError(1, 2)
    if err == nil {
        fmt.Println("returnError() ended normally!")
    } else {
        fmt.Println(err)
    }
    err = returnError(10, 10)
    if err == nil {
        fmt.Println("returnError() ended normally!")
    } else {
        fmt.Println(err)
    }
    if err.Error() == "Error in returnError() function!" {
        fmt.Println("!!")
    }
}
```

 функция `errors.Error()`,позволяет преобразовать переменную типа `error` в тип `string`.

 Создание ошибки
```go
 var err error = errors.New("An error")
 ```

## Обработка ошибок
Обработка ошибок является очень важной частью Go. Поскольку почти все функции Go возвращают сообщение об ошибке или nil, у Go есть способ сообщить, возникло ли состояние ошибки при выполнении функции.
```go
if err != nil {
 fmt.Println(err)
 os.Exit(10)
}
```
Вообще, вызов os.Exit() из функции, если только это не main(), считается плохой практикой. Функции, отличные от main(), как правило, перед выходом возвращают сообщение об ошибке, которое обрабатывается вызывающей функцией.

Если вы хотите отправить сообщение об ошибке не на экран, а в службу журна-
лирования, нужно изменить предыдущий Go-код следующим образом:
```go
if err != nil {
 log.Println(err)
 os.Exit(10)
}
```
Наконец, есть и другой вариант этого кода, который используется, когда случа-
ется что-то очень плохое и вы хотите срочно завершить программу:
```go
if err != nil {
 panic(err)
 os.Exit(10)
}
```
**Panic** — это встроенная Go-функция, которая останавливает выполнение про-
граммы
Лучше избегать ситуаций паники, по возможности заменяя ее обработкой ошибок.


## Использование Docker
создать собственный образ Docker
файл с именем hw.go существует и находится в текущем рабочем каталоге, можно создать новый образ Docker следующим образом:

```bash 
$ docker build -t go_hw:v1 .
```

Имя нового образа Docker — go_hw:v1

Чтобы убедиться, что образ Docker go_hw:v1 действительно существует на ва-
шем компьютере, нужно сделать следующее:

```bash
$ docker images
```

В файле hw.go содержится следующий код:
```go
package main
import (
 "fmt"
)
func main() {
 fmt.Println("Hello World!")
}
```
Образ Docker, который находится на локальном компьютере, можно использо-
вать следующим образом:
```bash
$ docker run go_hw:v1
Hello World!
```

# Упражнения и ссылки
- Посетите сайт Go: [https://golang.org/](https://golang.org/).
- Посетите сайт Docker: [https://www.docker.com/](https://www.docker.com/).
- Посетите сайт Docker Hub: [https://hub.docker.com/](https://hub.docker.com/).
- Посетите Go 2 Draft Designs: [https://blog.golang.org/go2draft](https://blog.golang.org/go2draft).
- Посетите сайт документации по Go: [https://golang.org/doc/](https://golang.org/doc/).
- Почитайте документацию пакета log: [https://golang.org/pkg/log/](https://golang.org/pkg/log/).
- Почитайте документацию пакета log/syslog: [https://golang.org/pkg/log/syslog/](https://golang.org/pkg/log/syslog/).
- Почитайте документацию пакета os: [https://golang.org/pkg/os/](https://golang.org/pkg/os/).
- Посетите [https://golang.org/cmd/gofmt/](https://golang.org/cmd/gofmt/) — страницу документации инструмента gofmt, который используется для форматирования Go-кода.
- Напишите Go-программу, которая вычисляет сумму всех аргументов командной строки, которые являются действительными числами.
- Напишите Go-программу, вычисляющую среднее значение всех чисел с плавающей запятой, переданных программе в качестве аргументов командной строки.
- Напишите Go-программу, которая считывает целые числа до тех пор, пока не встретит во входных данных слово END.

