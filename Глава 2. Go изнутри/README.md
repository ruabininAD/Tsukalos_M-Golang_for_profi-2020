# Компилятор Go
 Компилятор Go запускается с помощью инструмента `go`.

 Для того чтобы скомпилировать исходный файл Go, нужно воспользоваться командой `go tool compile`. В результате вы получите объектный файл — файл с расширением `.o` 

**Объектный файл** — это файл, в котором содержится объектный код, то есть машинный код в переносимом формате, который в большинстве случаев не может быть непосредственно выполнен. Главным преимуществом переносимого формата является то, что на этапе компоновки ему требуется минимум памяти.

Если при выполнении компиляции go tool использовать флаг командной строки -pack, то вместо объектного файла получим архивный файл: ` unsafe.a`

**Архивный файл** — это двоичный файл, внутри которого содержится один или несколько других файлов. Как правило, архивные файлы применяются для объединения нескольких файлов в один.

## Сборка мусора
    Сборка мусора (Garbage Collection, GC) — это процесс освобождения места в памяти, которое больше не используется. Другими словами, сборщик мусора определяет объекты, находящиеся вне области видимости, на которые нельзя больше ссылаться (недостижимые объекты), и освобождает занимаемую ими память. Этот процесс выполняется конкурентно, не до и не после, а во время работы Go-программы.

  Если перед любой командой go run поставить `GODEBUG=gctrace=1`, то Go выводит аналитические данные о работе сборщика мусора. Данные представлены в такой форме:  
  `gc 4 @0.025s 0%: 0.002+0.065+0.018 ms clock,  0.021+0.040/0.057/0.003+0.14 ms cpu, 47->47->0 MB, 48 MB goal, 8 P`

Здесь приводится подробная информация о размерах кучи в процессе сборки мусора. Возьмем для примера тройку значений 47->47->0 MB. Первое число — размер кучи перед запуском сборщика мусора; второе значение — размер кучи, когда сборщик завершает работу; последнее значение —актуальный размер кучи.

### Трехцветный алгоритм
 В основе работы сборщика мусора Go лежит трехцветный алгоритм.

 При запуске Go-программы планировщик Go составляет график работы собственно приложения и сборщика мусора — как если бы планировщик Go имел дело с обычным приложением, состоящим из нескольких горутин.

    Главный принцип алгоритма трехцветной пометки и очистки состоит в разделении объектов, находящихся в куче, на три набора, в соответствии с цветом, который назначается им алгоритмом. Пора обсудить значение каждого из этих цветов. Объекты черного цвета гарантированно не имеют указателей ни на один объект белого цвета. Однако объект белого цвета может иметь указатель на объект черного цвета, поскольку это не влияет на работу сборщика мусора. Объекты серого цвета могут иметь указатели на некоторые объекты белого цвета. Именно объекты белого цвета являются претендентами на удаление.

    Итак, когда начинается сборка мусора, все объекты становятся белыми. Сборщик мусора перебирает все корневые объекты и окрашивает их в серый цвет. Корневые объекты — это объекты, к которым приложение может обращаться напрямую, включая глобальные переменные и другие элементы, находящиеся в стеке. Большинство этих объектов зависят от Go-кода конкретной программы

    После этого сборщик мусора выбирает серый объект, помечает его черным и проверяет, есть ли у него указатели на другие объекты из белого множества. Это означает, что при проверке серого объекта на предмет указателей на другие объекты он окрашивается в черный цвет. Если проверка обнаружит, что у данного объекта есть один или несколько указателей на белые объекты, алгоритм поменяет цвет этих белых объектов на серый. Процесс продолжается до тех пор, пока не будут перебраны все объекты серого множества. Затем объекты белого множества считаются недостижимыми, и занимаемая ими память может использоваться повторно. Таким образом, считается, что в этот момент элементы белого множества попали в корзину.

    Приложение, работающее во время выполнения сборки мусора, называется мутатором. Мутатор запускает небольшую функцию, называемую барьером записи. Эта функция выполняется всякий раз, когда изменяется указатель в куче. Если указатель объекта в куче изменился, это означает, что данный объект теперь достижим. Барьер записи помечает этот объект в серый цвет и помещает в серое множество.

### Хеш-таблицы, срезы и сборщик мусора Go
Cледует быть осторожным при сборке мусора.
Cпособ хранения указателей сильно влияет на производительность сборщика мусора, особенно когда мы имеем дело с очень большим количеством указателей.
**Проведем эксперимент на СРЕЗЕ,  и Хеш-таблице
```go

package main
import (
 "runtime"
)
type data struct {
 i, j int
}
func main() {
 var N = 40000000
 var structure []data
 for i := 0; i < N; i++ {
 value := int(i)
 structure = append(structure, data{value, value})
 }
 runtime.GC()
 _ = structure[0]
}
```

```go
package main
import (
 "runtime"
)
func main() {
 var N = 40000000
 myMap := make(map[int]*int)
 for i := 0; i < N; i++ {
 value := int(i)
 myMap[value] = &value
 }
 runtime.GC()
 _ = myMap[0]
}
```
 Сравним между собой производительность этих четырех реализаций с помощью команды time(1)
```bash
$ time go run sliceGC.go
real 1.50s
user 1.72s
sys 0.71s
$ time go run mapStar.go
real 13.62s
user 23.74s
sys 1.89s
```
### Небезопасный код
    пакет unsafe
# Вызов C-кода из Go
## вызов из Go-программы
Самый простой способ вызвать C-код из Go-программы — включить код на C в исходный Go-файл.

```go 

package main
// #include <stdio.h>
// void callC() {
// printf("Calling C code!\n");
// }
import "C"


import "fmt"
func main() {
    fmt.Println("A Go statement!")
    C.callC()
    fmt.Println("Another Go statement!")
}
```
Для того чтобы выполнить C-функцию callC(), ее нужно вызвать как C.callC().

##  Вызов  C-кода в отдельных файлах
C-код нашего примера  содержится в двух файлах: callC.h и callC.c.
Файлы callC.c и callC.h хранятся в отдельном каталоге, который в данном случае называется callClib.

Подключаемый файл (callC.h)
```c
#ifndef CALLC_H
#define CALLC_H
void cHello();
void printMessage(char* message);
#endif
```

Исходный C-файл (callC.c) содержит следующий C-код:
```c
#include <stdio.h>
#include "callC.h"
void cHello() {
 printf("Hello from C!\n");
}
void printMessage(char* message) {
 printf("Go send me %s\n", message);
}
```
    В C-коде нет ничего, что бы указывало на то, что этот код будет вызываться из Go-программы. Главное — вызывать правильные C-функции с указанием верного количества параметров правильного типа. 
**Go-код**
```go

package main
// #cgo CFLAGS: -I${SRCDIR}/callClib
// #cgo LDFLAGS: ${SRCDIR}/callC.a
// #include <stdlib.h>
// #include <callC.h>
import "C"

import (
 "fmt"
 "unsafe"
)
func main() {
 fmt.Println("Going to call a C function!")
 C.cHello()

 fmt.Println("Going to call another C function!")
 myMessage := C.CString("This is Mihalis!")
 defer C.free(unsafe.Pointer(myMessage))

 C.printMessage(myMessage)
 fmt.Println("All perfectly done!")
}
```
Чтобы передать строку из Go в C-функцию, нужно создать строку в формате C с помощью C.CString(). Кроме того, нам понадобится оператор defer, чтобы освободить память, занимаемую строкой C, после того как она будет использована. Оператор defer включает в себя вызов функции C.free() и затем unsafe.Pointer()

нужно скомпилировать C-код, чтобы создать библиотеку, для чего следует выполнить такие команды:
```bash
$ gcc -c callClib/*.c
$ /usr/bin/ar rs callC.a *.o
ar: creating archive callC.a
```
У нас появится файл с именем callC.a, расположенный в том же каталоге, что и callC.go

Теперь мы готовы скомпилировать файл с Go-кодом и создать новый исполняемый файл:

```bash
$ go build callC.go
```
    Если вам нужно использовать небольшое количество C-кода, то весьма желательно использовать общий Go-файл для кода на C и на Go — так проще. Но если вы собираетесь сделать что-то большое и сложное, лучше создать статическую C-библиотеку

## Вызов Go-функций из C-кода

asdasdasd

# Ключевое слово defer
Ключевое слово defer позволяет отложить выполнение функции до тех пор, пока не потребуется вернуть значение внешней функции.

Очень важно учитывать, что после возвращения из внешней функции отложенные функции выполняются в порядке «последним пришел — первым вышел»

Это означает, что если сначала отложить функцию f1(), затем функцию f2() и после нее — функцию f3() в одной и той же внешней функции, то, когда эта внешняя функция будет возвращать значение, функция f3()выполнится первой, функция f2() — второй, а функция f1() — последней.

# Функции panic() и recover()
Строго говоря, panic() — это встроенная функция Go, которая завершает текущий поток Go-программы и начинает бить тревогу. Что же касается функции recover(), которая также является встроенной функцией Go, то она позволяет вернуть контроль над программой, которая только что запаниковала, запустив panic().

```go

package main
import (
 "fmt"
)
func a() {
 fmt.Println("Inside a()")
 defer func() {
 if c := recover(); c != nil {
 fmt.Println("Recover inside a()!")
 }
 }()
 fmt.Println("About to call b()")
 b()
 fmt.Println("b() exited!")
 fmt.Println("Exiting a()")
}
func b() {
 fmt.Println("Inside b()")
 panic("Panic in b()!")
 fmt.Println("Exiting b()")
}

func main() {
 a()
 fmt.Println("main() ended!")
}

```
В функции a() реализован блок кода defer. В нем реализована анонимная функция, которая будет вызываться при вызове panic().

# Среда Go 
Как вы вскоре увидите, в пакет runtime входят функции и свойства, которые предоставят  информацию о состоянии во время выполнения.
```go
package main
import (
 "fmt"
 "runtime"
)

func main() {
 fmt.Print("You are using ", runtime.Compiler, " ")
 fmt.Println("on a", runtime.GOARCH, "machine")
 fmt.Println("Using Go version", runtime.Version())
 fmt.Println("Number of CPUs:", runtime.NumCPU())
 fmt.Println("Number of Goroutines:", runtime.NumGoroutine())
}

```

## Команда go env
  список всех переменных среды, поддерживаемых языком и компилятором Go, а также текущие значения этих переменных, то следует выполнить команду `go env`.
## Go-ассемблер
  `$ GOOS=darwin GOARCH=amd64 go tool compile -S goEnv.go`
  Значение переменной GOOS определяет имя операционной системы, для которой создается программа, а значение переменной GOARCH — архитектуру компиляции. Эта команда выполнена на компьютере с macOS Mojave, поэтому переменной GOOS было присвоено значение darwin.

  Переменная GOOS может принимать значения android, darwin, dragonfly, freebsd, linux, nacl, netbsd, openbsd, plan9, solaris, windows и zos; переменная GOARCH — значения 386, amd64, amd64p32, arm, armbe, arm64, arm64be, ppc64, ppc64le, mips, mipsle, mips64, mips64le, mips64p32, mips64p32le, ppc, s390, s390x, spar, spar и sparc64

## Узловые деревья
 Узлы Go (nodes) — это объекты типа struct с большим количеством свойств. Подробнее об определении и использовании структур в Go вы узнаете из главы 4. Все элементы Go-программы подвергаются синтаксическому разбору и анализируются модулями компилятора Go в соответствии с грамматикой языка. Конечным результом анализа Go-кода являются соответствующее ему дерево. Дерево — это альтернативный способ представления программы, предназначенный не для разработчика, а для компилятора.
 `go tool compile -W test.go`
```bash
 $ go tool compile -W nodeTree.go | grep before 
before walk main
before walk init
$ go tool compile -W nodeTree.go | grep after
after walk main
after walk init
```
ключевое слово before означает начало выполнения функции.

# Создание кода WebAssembly
## Краткое введение в WebAssembly
 WebAssembly (Wasm) — это машинная модель и исполняемый формат для виртуальной машины, разработанный для повышения скорости и сокращения размера файла. Это означает, что двоичный файл WebAssembly можно использовать на любой платформе без каких-либо изменений

## Почему WebAssembly так важен
 - код WebAssembly работает со скоростью, очень близкой к «родной» скорости машины, то есть быстро;
 - код WebAssembly можно генерировать из многих языков программирования, 
 -  том числе, возможно, и тех, которые вы уже знаете;
 -  большинство современных браузеров изначально поддерживают WebAssembly, не требуя подключения плагина или какого-либо другого программного обеспечения;
 -  код WebAssembly работает намного быстрее, чем код JavaScript.

## Go и WebAssembly
Для создания кода WebAssembly допускается использовать возможности кросс-ком-
пиляции Go. ОЧЕНЬ ИНТЕРЕСНО НО СЛОЖНО 



# Общие рекомендации по программированию на Go
- Если в Go-функции произошла ошибка, журналируйте ее или передайте ее на уровень выше; не делайте того и другого одновременно, если только у вас нет на это действительно веской причины.
- Интерфейсы Go определяют поведение, а не данные и не структуру данных.
- По возможности используйте интерфейсы `io.Reader` и `io.Writer` — благодаря им получается более расширяемый код.
- Не передавайте в функцию указатель на простую переменную, если этого можно избежать. Лучше передайте значение переменной.
- Переменные ошибок (`errors`) не то же самое, что строковые переменные; это переменные ошибок!
- Не проверяйте Go-код на компьютерах, относящихся к среде эксплуатации, если только на это нет веских причин.
- Если вы недостаточно хорошо знаете какие-либо особенности Go, протестируйте их, прежде чем использовать, особенно если вы разрабатываете приложение или утилиту, которой будет пользоваться много людей.
- Если вы боитесь делать ошибки, то, скорее всего, в итоге вам не удастся сделать ничего по-настоящему интересного. Экспериментируйте, насколько хватит сил!

# Упражнения и ссылки
1. Познакомьтесь ближе со стандартным Go-пакетом `unsafe`, посетив страницу его документации [здесь](https://golang.org/pkg/unsafe/).

2. Посетите сайт DTrace по адресу [http://dtrace.org/](http://dtrace.org/).

3. Используя `strace(1)`, проверьте, как на вашем Linux-компьютере работают стандартные UNIX-утилиты, такие как `cp(1)` и `ls(1)`. Каковы оказались результаты проверки?

4. Если у вас машина с macOS, воспользуйтесь `dtruss(1)`, чтобы проверить, как работает утилита `sync(8)`.

5. Напишите собственный пример использования вашего C-кода из Go-программы.

6. Напишите Go-функцию и используйте ее в программе на C.

7. Узнайте больше о функциях пакета `runtime`, посетив страницу [здесь](https://golang.org/pkg/runtime/).

8. Читать научные труды бывает непросто, но это очень полезно. Скачайте статью "On-the-Fly Garbage Collection: An Exercise in Cooperation" и изучите ее. Эту статью можно найти на многих ресурсах, включая [https://dl.acm.org/citation.cfm?id=359655](https://dl.acm.org/citation.cfm?id=359655).

9. Посетите страницу [https://github.com/gasche/gc-latency-experiment](https://github.com/gasche/gc-latency-experiment), где вы найдете код для сравнительного анализа производительности сборщиков мусора в различных языках программирования.

10. Чтобы больше узнать о Node.js, посетите веб-сайт [https://nodejs.org/en/](https://nodejs.org/en/).

11. Подробнее о WebAssembly вы можете узнать на сайте [https://webassembly.org/](https://webassembly.org/).

12. Если хотите узнать больше о сборке мусора, обязательно посетите сайт [http://gchandbook.org/](http://gchandbook.org/).

13. Посетите страницу документации cgo по адресу [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/).
