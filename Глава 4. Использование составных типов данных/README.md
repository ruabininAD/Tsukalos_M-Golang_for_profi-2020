# Составные типы данных


## структуры и ключевое слово struct в Go;
 Структура - тип данных, содержащий несколько переменных разных типов.

 Элементы структуры называются *полями* структуры.

```go
type dog struct{
    Height int
    weight int 
    Name string
    vaccination bool 
}


// создание переменной с типом dog
var d1 dog

// создание переменной с использованием литералов
d2 := dog{100, 50, "boss", true}

// создание переменной
d2 := dog{Height:100, weight:50,vaccination: true,  Name:"boss"}
```

    Типы Go и структуры в частности, как правило, определяются вне функции main(), чтобы они относились к глобальной области видимости и были доступны для всего пакета Go, если только вы не хотите специально подчеркнуть, что данный тип полезен лишь в пределах текущей области видимости и его не предполагается использовать в других местах

    Обратите внимание, что последовательность, в которой вы добавляли поля в определение типа структуры, имеет значение для идентификации типа этой структуры. Проще говоря, две структуры с одинаковыми полями в Go не будут считаться одинаковыми, если эти поля определены у них в разном порядке.


Наиболее распростарненной практикой явзяется создание функции - конструктора, которая принимает значения структуры, проверяет их н корректность и возвращает ссылку на структуру.

```go
type myStructure struct {
 Name string
 Surname string
 Height int32
}

func createStruct(n, s string, h int32) *myStructure {
 if h > 300 {
    h = 0
 }
 return &myStructure{n, s, h}
}
```

### Ключевое слово new
 ключевое слово new, которое позволяет размещать в памяти новые объекты. Однако, используя new, нужно помнить очень важную деталь: new возвращает адрес памяти выделенного объекта. Проще говоря, new возвращает указатель.


    Основное различие между new и make состоит в том, что переменные, созданные с помощью make, правильно инициализируются, а не только обнуляется выделенная для них память. Кроме того, make можно применять только к хеш-таблицам, каналам и срезам, и эта функция не возвращает адрес памяти, то есть make не возвращает указатель.
## Кортежи в Go;
 **кортеж** — это конечный упорядоченный список, состоящий из разных типор данных.

 Go не поддерживает тип кортежа

 Но функционл возврата из функции нескольких значений реализован с помощью кортежа.

 ```go
func retThree(x int) (int, int, int) {
 return 2 * x, x * x, -x
}
 ```
Реализация функции `retThree()`, которая возвращает кортеж,содержащий три целочисленных значения

## Регулярные выражения в Go;
## Сопоставление с образцом в Go;
Пакет Go, отвечающий за определение регулярных выражений и сопоставле-
ние с образцом, называется `regexp`.

    Важно помнить, что никогда не следует доверять входным данным, особенно если они получены от нетехнических пользователей. Проще говоря, всегда проверяйте, являются ли входные данные тем, что вы ожидали получить
## Строки, руны и строковые литералы;
Строки в Go не являются составным типом

Строки в Go являются переменными, хранящими значения, а не указателями, как строки в C.

Строка Go — это байтовый срез, предназначенный только для чтения, который может содержать байты любого типа и иметь произвольную длину

Строковый литерал можно определить следующим образом:
`const sLiteral = "\x99\x42\x32\x55\x50\x35\x23\x50\x29\x9c"`

`s2 := "€£3"`

###  Руны
Руны — это значения типа int32, следовательно, тип Go, который используется для представления кодовых пунктов Unicode.  
Пример в Unicode.go

Пакет strings  
Стандартный пакет Go strings позволяет манипулировать строками UTF-8 в Go


## Оператор switch;  
```go
switch asString {
case "1":
 fmt.Println("One!")
case "0":
 fmt.Println("Zero!")
default:
 fmt.Println("Do not care!")
}
```

```go
switch {
case number < 0:
 fmt.Println("Less than zero!")
case number > 0:
 fmt.Println("Bigger than zero!")
default:
 fmt.Println("Zero!")
}
```

Пример использвания   с регулярными выражениями 
```go
var negative = regexp.MustCompile(`-`)
 var floatingPoint = regexp.MustCompile(`\d?\.\d`)
 var email = regexp.MustCompile(`^[^@]+@[^@.]+\.[^@.]+`)
 switch {
 case negative.MatchString(asString):
 fmt.Println("Negative number")
 case floatingPoint.MatchString(asString):
 fmt.Println("Floating point!")
 case email.MatchString(asString):
 fmt.Println("It is an email!")
 fallthrough
 default:
 fmt.Println("Something else!")
}
```
## Вычисление числа π с высокой точностью;
Используй пакет `math/big`
## Разработка хранилища типа «ключ — значение».

## Работа с текстовым форматом JSON;
В пакете encoding/json реализованы функции Encode() и Decode(), которые позволяют преобразовать объект Go в документ JSON и наоборот. Кроме того, в пакет encoding/json входят функции Marshal() и Unmarshal()
## Работа с текстовым форматом XML;